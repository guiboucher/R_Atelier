---
title: "data.table"
# author: "Yihui Xie"
institute: "INESSS"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    yolo: false
---
```{r setup, include=FALSE, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "#>")
```
```{css, echo=FALSE}
.textfont15 {font-size: 15px}
.textfont16 {font-size: 16px}
.textfont17 {font-size: 17px}
.textfont18 {font-size: 18px}
.textfont19 {font-size: 19px}
.textfont20 {font-size: 20px}
.code75 .remark-code {font-size: 75%}
.code80 .remark-code {font-size: 80%}
.code85 .remark-code {font-size: 85%}
.code88 .remark-code {font-size: 88%}
.code90 .remark-code {font-size: 90%} /*Par défaut*/
.code95 .remark-code {font-size: 95%}


/* *** EXEMPLES ***
.my-style {
  font-weight: bold;
  font-style: italic;
  font-size: 1.5em;
  color: red;
}
.foobar code.r {
  font-weight: bold;
}
.foobar code[class="remark-code"] {
  display: block;
  border: 1px solid red;
}
.remark-slide-content {
  font-size: 28px;
  padding: 20px 80px 20px 80px;
}
.remark-code, .remark-inline-code {
  background: #f0f0f0;
}
.remark-code {
  font-size: 24px;
}
.huge .remark-code {
  font-size: 200% !important;
}
.tiny .remark-code {
  font-size: 50% !important;
}
*/
```

# data.table
```{r, warning=FALSE}
library(data.table)
```

`dt[i, j, by]`

- **_dt_ :** Nom du `data.table`
- **_i_ :** Sous-ensemble de lignes, lignes à utiliser
- **_j_ :** Colonnes à manipuler
- **_by_ :** Regrouper par `by`

---
class: code80

### Créer un data.table

```{r}
df1 <- data.frame(a = c(1, 2, 4), b = c("a", "b", "d"), c = c(111, 222, 333))
dt <- data.table(a = c(1, 2, 4), b = c("a", "b", "d"), c = c(111, 222, 333))
dt2 <- as.data.table(df1)
setDT(df1)  # Utile pour les grosses bases de données
            # Efficace au niveau de la mémoire. Ne fait pas de copie.
str(df1)
```

---

### Sélection de lignes avec `i`

En indiquant les numéros de lignes
```{r}
dt[c(2, 3)]
```

Selon un opérateurs
```{r}
dt[a > 2]
```

---

### Extraire des colonnes

Par numéro
```{r}
dt[, c(2)]
dt[, c(-2)]  # Un signe négatif exclu la colonne
```

---

### Extraire des colonnes

Par nom
```{r}
dt[, .(a, c)]

cols <- c("a", "c")
dt[, ..cols]
```

---

### Les fonctions *set* ou le symbole *:=*
Les fonctions avec le préfixe `set` ou les colonnes créées à partir de `:=` modifient les données sans faire de copie. En d'autres mots, pas besoin d'utiliser le `<-`.

---
### Création de colonnes

```{r}
dt
dt[, d := 1 + 2]
```
```{r, echo=FALSE}
dt
```

---

### Création de colonnes
Pour un sous-ensemble de lignes
```{r, echo=FALSE}
dt[, d := NULL]
```
```{r}
dt[a == 1, d := 1 + 2]
```
```{r, echo=FALSE}
dt
```
Les lignes non sélectionnées auront des `NA`

---

### Création de colonnes
Pour créer plusieurs colonnes en même temps
```{r, echo=FALSE}
dt[, d := NULL]
```
```{r}
dt[, `:=` (d = 2, e = 2+3)]
```
```{r, echo=FALSE}
dt
```

---

### Supprimer une colonne
```{r}
dt
dt[, d := NULL]
```
```{r, echo=FALSE}
dt
```

---

### Regrouper selon `by`

Calculer la colonne `j` en regroupant par la colonne `a`
> `dt[, j, by = .(a)]`

Calculer la colonne `j` en regroupant par la colonne `a` et trier en ordre croissant la colonne `a`
> `dt[, j, keyby = .(a)]`

---

### Regrouper selon `by`
```{r, echo=FALSE}
dt2 <- data.table(a = c(1,1,2), b = c(4, 5, 6))
```
```{r}
dt2
```
Résumer les lignes au sein des groupes
```{r}
dt2[, .(c = sum(b)), by = a]
```

---

### Regrouper selon `by`
Créer une nouvelle colonne et calculer les lignes au sein des groupes.
```{r}
dt2[, c := sum(b), by = a]
```
```{r, echo=FALSE}
dt2
```

---

### Regrouper selon `by`
Extraire les premières observations d'un groupe
```{r}
dt2[, .SD[1], by = a]  # .SD = Subset data
```

Extraire les dernières observations d'un groupe
```{r}
dt2[, .SD[.N], by = a]  # .N est la dernière valeur
```

---

### Enchainement d'opérations (*chaining*)

Il est possible d'enchainer les opérations avec les *pipes* `[]`
> `dt[...][...][...]`

```{r}
dt[, e := NULL][, d := 1+3][, e := sum(c), by = a]
# 1) Supprimer colonne e
# 2) Créer colonne d = 4
# 3) Créer colonne e = somme de c groupé par colonne a
```

---

### Exemple de fonctions `set`
```{r}
# Trier les données par a croissant et b décroissant
setorder(dt, a, -b)

# Order des colonnes
setcolorder(dt, c("b", "c", "a", "e", "d"))

# Renommer les colonnes a et b par col1 et col2
setnames(dt, old = c("a", "b"), new = c("col1", "col2"))  
```


---

###  Jointure *left join*
```{r, echo=FALSE}
dt_a <- data.table(a = 1:3, b = c("c", "a", "b"))
dt_b <- data.table(x = 3:1, y = c("b", "c", "a"))
```
.pull-left[
  ```{r}
  dt_a
  ```
]
.pull-right[
  ```{r}
  dt_b
  ```
]
```{r}
dt_a[dt_b, on = .(b = y)]
```

---

###  Jointure *left join*
```{r, echo=FALSE}
dt_a <- data.table(a = 1:3, b = c("c", "a", "b"), c = c(7, 5, 6))
dt_b <- data.table(x = 3:1, y = c("b", "c", "a"), z = c(4, 5, 8))
```
.pull-left[
  ```{r}
  dt_a
  ```
]
.pull-right[
  ```{r}
  dt_b
  ```
]
```{r}
dt_a[dt_b, on = .(b = y, c > z)]
```

---

### *Rolling join*

Jointure qui connserve la correspondance **la plus récente** avec la table de données de gauche. «roll = -Inf» inverse le sens.
```{r, echo=FALSE}
dt_a <- data.table(
  a = c(1,2,3,1,2),
  id = c("A", "A", "A", "B", "B"),
  date = as.Date(c("2010-01-01", "2012-01-01", "2014-01-01", "2010-01-01", "2012-01-01"))
)
dt_b <- data.table(
  b = 1,
  id = c("A", "B"),
  date = as.Date(c("2013-01-01", "2013-01-01"))
)
```
.pull-left[
  ```{r}
  dt_a
  ```
]
.pull-right[
  ```{r}
  dt_b
  ```
]
```{r}
dt_a[dt_b, on = .(id = id, date = date), roll=TRUE]
```
Dans les deux cas, les dates qui précèdent 2013-01-01 de `dt_b` sont 2012-01-01 dans `dt_a`.

---

### Lier - Lignes

```{r, echo=FALSE}
dt_a <- data.table(
  id = 1,
  x = 1:2
)
dt_b <- data.table(
  id = 2,
  x = 5
)
```
.pull-left[
  ```{r}
  dt_a
  ```
]
.pull-right[
  ```{r}
  dt_b
  ```
]
```{r}
rbind(dt_a, dt_b)
```

---

### Lier - Colonnes

```{r, echo=FALSE}
dt_a <- data.table(
  id = 1,
  x = 1:2
)
dt_b <- data.table(
  y = 5:6
)
```
.pull-left[
  ```{r}
  dt_a
  ```
]
.pull-right[
  ```{r}
  dt_b
  ```
]
```{r}
cbind(dt_a, dt_b)
```

---

### Transformer au format large

```{r, echo=FALSE}
dt <- data.table(
  id = c(1, 1, 2, 2),
  variable = c("A", "B", "A", "B"),
  valeur = c(10, 20, 15, 25)
)
```
```{r, warning=FALSE}
dt
dcast(dt, id ~ variable, value.var = "valeur")
```

---

### Transformer au format long

```{r, echo=FALSE}
dt <- data.table(
  id = 1:3,
  Var1 = c(10, 20, 30),
  Var2 = c(100, 200, 300)
)
```
```{r, warning=FALSE}
dt
melt(dt, id.vars = "id", measure.vars = c("Var1", "Var2"))
```

---

### Appliquer une fonction sur plusieurs colonnes
```{r, echo=FALSE}
dt <- data.table(a = 1:3, b = 4:6)
dt
```
```{r}
dt[, lapply(.SD, mean), .SDcols = c("a", "b")]

cols <- c("a", "b")
dt[, paste0(cols, "_m") := lapply(.SD, mean), .SDcols = cols]
```
```{r, echo=FALSE}
dt
```

---

### Séquence - Index

Indiquer de 1 à N les lignes d'un même groupe
```{r, echo=FALSE}
dt <- data.table(a = 1:3, b = c("A", "A", "B"))
```
```{r}
dt[, c := 1:.N, by = .(b)]
```
```{r, echo=FALSE}
dt
```

---

### Valeur précédente ou suivante

```{r, echo=FALSE}
dt <- data.table(A = 1:5, B = c("X", "X", "X", "Y", "Y"))
```
```{r}
# Valeur précédente de A par B
dt[, C := shift(A, 1), by = B]
```
```{r, echo=FALSE}
dt
```

```{r}
# Valeur suivante de A par B
dt[, C := shift(A, 1, type =  "lead"), by = B]
```
```{r, echo=FALSE}
dt
```

---

### Import / Export

Importer un fichier .csv
```{r, eval=FALSE}
fread()
```
Exporter un fichier .csv
```{r, eval=FALSE}
fwrite()
```


Bien que `fread()` et `fwrite()` soient très rapides, je conseille de rester avec `saveRDS()`/`readRDS()` et `save()`/`load()` qui prennent beaucoup moins d'espace (fichier compressé) et permette une meilleure intégrité des données. Par exemple, il pourrait arriver que les dates ne s'affichent pas correctement.


---
class: code75

### Symboles spéciaux

```{r, echo=FALSE}
dt = data.table(x=rep(c("b","a","c"),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1)
```

.pull-left[
  ```{r, echo=FALSE}
  dt
  ```
  ```{r}
  # Dernière ligne
  dt[.N]
  ```
]
.pull-right[
  ```{r}
  # Nombre de lignes
  dt[, .N]
  
  # Nombre de lignes dans chaque groupe
  dt[, .N, by=x]
  ```
]
---
class: code75

### Symboles spéciaux
.pull-left[
  ```{r, echo=FALSE}
  dt
  ```
  ```{r}
  # Sélectionne les colonnes x à y
  dt[, .SD, .SDcols=x:y]
  ```
]
.pull-right[
  ```{r}
  # Première ligne de chaque colonne
  dt[, .SD[1]]
  # Première ligne de chaque colonne
  # de chaque groupe dans 'x'
  dt[, .SD[1], by=x]
  ```
]
---
class: code75

### Symboles spéciaux
.pull-left[
  ```{r, echo=FALSE}
  dt
  ```
  ```{r}
  
  ```
]
.pull-right[
  ```{r}
  # Numéro de la première ligne par
  # groupe de x
  dt[, .I[1], by=x]
  # Numéro de la dernière ligne par
  # groupe de x
  dt[, .I[.N], by=x]
  ```
]

---
class: code75

### Symboles spéciaux
.pull-left[
  ```{r, echo=FALSE}
  dt[, `:=` (a = NULL, v = NULL)]
  dt
  ```
  ```{r}
  # Itérateur de groupe
  dt[, grp := .GRP, keyby=x]
  ```
  ```{r, echo=FALSE}
  print(dt)
  ```
]
.pull-right[
  ```{r}
  # Itérateur de groupe avec un compteur
  # de progrès
  dt[
    , grp_pct := round(.GRP/.NGRP, 2),
    by=x
  ]
  ```
  ```{r, echo=FALSE}
  dt
  ```
]

---

### Exemple avancé avec dt[, .I\[ \]\]

Prescription à un patient
```{r, echo=FALSE}
dt <- data.table(
  ID = c(1, 1, 1, 2),
  DateRx = as.Date(c("2020-01-01", "2020-01-20", "2020-02-01", "2020-06-01")),
  nJours = c(30, 5, 30, 30)
)
dt
```
```{r}
dt[, DateFin := DateRx + nJours - 1]
dt[, diff := as.integer(DateRx - shift(DateFin)), .(ID)]
```
```{r, echo=FALSE}
dt
```

---

```{r, echo=FALSE}
dt
```
```{r}
dt[, .I[diff < 1], .(ID)]
idx <- c(
  dt[, .I[diff < 1], .(ID)]$V1-1,
  dt[, .I[diff < 1], .(ID)]$V1
)
idx <- sort(idx[!is.na(idx)])
idx
```

---

```{r}
dt[idx, ajout := shift(nJours, -1), .(ID)]
```
```{r, echo=FALSE}
dt
```
```{r}
dt[!is.na(ajout), nJours := nJours + ajout]
```
```{r, echo=FALSE}
dt
```


---

```{r, echo=FALSE}
dt
```
```{r}
dt <- dt[!dt[, .I[diff < 1], .(ID)]$V1]
```
```{r, echo=FALSE}
dt
```

---

**Attention si plusieurs périodes doivent être fusionnées**
```{r, echo=FALSE}
dt <- data.table(
  ID = c(1, 1, 1, 2),
  DateRx = as.Date(c("2020-01-01", "2020-01-20", "2020-01-22", "2020-06-01")),
  nJours = c(30, 5, 30, 30)
)
dt[, DateFin := DateRx + nJours - 1]
dt[, diff := as.integer(DateRx - shift(DateFin)), .(ID)]
dt[is.na(diff), diff := 0L]
```
```{r, echo=FALSE}
dt
```

On doit s'assurer de ne pas avoir trois nombres qui se suivent pour un même ID et répéter les étapes dans un `while loop`.  
À faire en devoir! :P

























































